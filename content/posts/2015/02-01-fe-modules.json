{
  "layout": "post",
  "title": "前端模块化 - CommonJS、AMD与CMD",
  "description": "学习SeaJS，了解前端js模块化编程，CommonJS、AMD与CMD的比较",
  "keywords": "SeaJS, CMD, AMD, CommonJS, RequireJS, Node.js",
  "date": "2015-02-01T00:06:10.000Z",
  "categories": "seajs",
  "bodyContent": "AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。\n\nCMD 是 SeaJS 在推广过程中对模块定义的规范化产出。\n\n--玉伯\n\n\n第一次听说 SeaJS，已经是两年前的事了，但一直没有机会让我意识到模块化对于前端开发的好处，所以也没有深入去了解使用 SeaJS 或者 RequireJS 这类的模块加载器进行模块化编程。\n\n随着公司项目越来越大，不管是代码维护还是新功能模块的添加，都越显困难与无力。模块化编程现在已经非常成熟，很多大的公司项目已经在使用，例如 QQ 空间、淘宝等。模块化编程在发展过程中，已经形成了多套规范以及基于不同规范的框架。本博文是我在探讨这些规范以及模块化框架过程中的一些总结与记录，已作分享以及备忘使用。\n\n\n## 1. CommonJS规范\n\nCommonJS 是服务器端模块化的规范，Node.js 就是基于 CommonJS Modules/1.0。\n\n根据 CommonJS 规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，在改模块内定义的变量无法被其他模块所读取，除非定义为global对象的属性。\n\n``` javascript\n// main.js\n\nglobal.name = 'Frend';\n```\n\n以上定义的 name 变量可以被所有的模块所读取，但是并不推荐这种方式。输出模块的变量，最好的方式是使用 exports(module.exports) 对象。关于 `exports 与 module.exports的区别` 推荐看[一位全栈码农对 exports 与 module.exports 的分析](http://zihua.li/2012/03/use-module-exports-or-exports-in-node/)。如果这篇博文让你还是理解不了，那给出一个更加浅显的说明：exports 一般是一个对象，用于挂一堆的方法或者属性，例如一个 slider 滑动模块，有一堆的控制方法和属性，这种情况下就可以用 exports 来挂载，而另外一种情况，例如这个模块是叫 $G.dom.get，实现和 jQuery 的 $() 一样的功能，这时候不需要额外的一些乱七八糟的东西，只需要它是个方法，能直接调用，这时就可以使用 module.exports 了，调用的时候就可以直接通过 $get = require( './dom/get' ); $get 方法来使用了。\n\n``` javascript\n// module_a.js\n\nexports.name = 'Frend';\n\nexports.say = function() {\n  console.log(name);\n}\n```\n\n使用 require 方法，加载 module_a.js\n\n``` javascript\n// main.js\n\nvar module_a = require('./module_a.js');    // 同步加载模块，加载完再执行后面的代码\n\nmodule_a.say(); // Frend\n```\n\n## 2. AMD规范\n\n从 [#CommonJS 规范#](#commonjs)已经初步了解了 CommonJS，它加载模块时是同步的，也就是说，只有加载完成才会开始执行后面的操作。由于 Node.js 主要是用于服务器编程，模块文件一般是存放在服务器硬盘，所以加载会非常的快，不用考虑像浏览器请求脚本时造成阻塞等的情况，所以 CommonJS 规范比较适用。但是，如果是在浏览器，要从服务器加载模块，带宽是主要的瓶颈，所以 AMD 规范提倡的异步加载模块的方式比较适用。\n\nAMD（Asynchronous Module Definition）规范则是异步加载模块，即模块的加载不会影响后面语句的运行。所有依赖于某些模块的语句均放在回调函数中执行。\n[AMD规范](https://github.com/amdjs/amdjs-api/wiki/AMD)\n\n\n### 2.1 AMD 的全局变量 —— define 函数\n\n#### define(id?, dependencies?, factory)\n\n`id` 为可选参数，字符串类型，表示当前模块的标识。\n\n`dependencies` 可选参数，当前模块所依赖并已经被定义的模块标志的数组字面量。\n\n`factory` 一个模块需要执行一次的函数或者是分配了模块属性的的对象。\n\n* 创建模块标识为 alpha 的模块，依赖于 require，export，和标识为 beta 的模块\n\n``` javascript\ndefine('alpha', ['require', 'exports', 'beta'], function(require, exports, beta) {\n  export.verb = function() {\n    return beta.verb();\n  }\n});\n```\n\n* 一个返回对象字面量的异步模块\n\n``` javascript\ndefine(['alpha'], function(alpha) {\n  return {\n    verb: function() {\n      return alpha.verb() + 1 ;\n    }\n  };\n});\n```\n\n* 无依赖模块可以直接使用对象字面量来定义\n\n``` javascript\ndefine({\n  add: function(x, y) {\n    return x + y;\n  }\n});\n```\n\n* 兼容 CommonJS 的写法\n\n``` javascript\ndefine(function(require, exports, module) {\n  var a = require('a'),\n      b = require('b');\n\n  exports.action = function(){};\n});\n```\n\n### 2.2 AMD 的 factory 中的 require 参数\n\n* require(String)\n\n``` javascript\ndefine(function(require) {\n  var a = require('a');   // 加载模块a\n});\n```\n\n* require(Array, Function)\n\n``` javascript\ndefine(function(require) {\n  require(['a', 'b'], function(a, b) {    // 加载模块a b 使用\n    // 依赖 a b 模块的运行代码\n  });\n});\n```\n\n* require.toUrl(Url)\n\n``` javascript\ndefine(function(require) {\n  var temp = require.toUrl('./temp/a.html');  // 加载页面\n});\n```\n\n## 3. CMD规范\n\nCMD（Common Module Definition）规范是 SeaJS 遵循的规范，明确了模块的基本书写格式和基本交互规则。\n\n在该规范中，一个模块就是一个文件。\n\n###3.1 CMD 的全局变量 —— define 函数\n\n#### define(id?, dependencies?, factory)\n\n`id` 为可选参数，字符串类型，表示当前模块的标识。\n\n`dependencies` 为可选参数，数组类型，表示当前模块的依赖。\n\n`factory` 可以是对象、字符串或者函数\n\n* 定义 JSON 数据模块\n\n``` javascript\ndefine({'foo': 'bar'});\n```\n\n* 通过字符串定义模板模块\n\n``` javascript\ndefine('this is {{data}}.');\n```\n\n* factory 为函数的时候，表示模块的构造方法，执行构造方法便可以得到模块向外提供的接口\n\n``` javascript\ndefine(function(require, exports, module) {\n  // 模块代码\n});\n```\n\n* 当拥有两个以上参数时\n``` javascript\ndefine('module', ['module1', 'module2'], function(require, exports, module) {\n  // 模块代码\n});\n```\n\n从上面代码对比来看，CMD 与 AMD 规范在 define 函数上用法不相同。\n\n### 3.2 CMD 的 factory 中的 require 参数\n\n* `require(id);` 接受模块标识作为唯一的参数，用来获取其他模块提供的接口\n\n``` javascript\ndefine(function(require, exports) {\n  var a = require('./a');\n\n  a.doSomething();\n});\n```\n\n* `require.async(id, callback?);` require 是同步往下执行的，需要的异步加载模块可以使用 require.async 来进行加载\n\n``` javascript\ndefine(function(require, exports, module) {\n  require.async('.a', function(a) {\n    a.doSomething();\n  });\n});\n```\n\n### 3.3 CMD 的 factory 中的 exports 参数\n\n* exports 用来向外提供模块接口\n\n``` javascript\ndefine(function(require, exports) {\n  exports.foo = 'bar';         // 向外提供的属性\n  exports.do = function() {};  // 向外提供的方法\n});\n```\n\n* 使用 return 直接向外提供接口\n\n``` javascript\ndefine(function(require, exports) {\n  return {\n    foo: 'bar',         // 向外提供的属性\n    do: function() {}   // 向外提供的方法\n  }\n});\n```\n\n* 简化为直接对象字面量的形式\n\n``` javascript\ndefine({\n  foo: 'bar',           // 向外提供的属性\n  do: function() {}     // 向外提供的方法\n});\n```\n\n* 与 NodeJS 中一样需要注意的情况\n\n``` javascript\n// wrong\ndefine(function(require, exports) {\n  exports = {\n    foo: 'bar',           // 向外提供的属性\n    do: function() {}     // 向外提供的方法\n  }\n});\n\n// correct\ndefine(function(require, exports, module) {\n  module.exports = {\n    foo: 'bar',           // 向外提供的属性\n    do: function() {}     // 向外提供的方法\n  }\n});\n```\n\n### 3.4 CMD 的 factory 中的 module 参数\n\n* module 是 factory 的第三个参数，为一个对象，上面存储了一些与当前模块相关联的属性与方法\n\n``` javascript\nmodule.id           // 为模块的唯一标识。\nmodule.uri          // 根据模块系统的路径解析规则得到模块的绝对路径。\nmodule.dependencies // 表示模块的依赖。\nmodule.exports      // 当前模块对外提供的接口。\n```\n\n## 4. AMD 与 CMD 的区别\n\n下面是玉伯对于 AMD 与 CMD 区别的解释：\n\nAMD 是 RequireJS 在推广过程中对模块定义的规范化产出。\n\nCMD 是 SeaJS 在推广过程中对模块定义的规范化产出。\n\nAMD与CMD都是为了实现javascript的模块化开发，特别是在浏览器端。下面介绍两者的区别：\n\n1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.\n\n2. CMD推崇依赖就近，AMD推崇依赖前置。\n\n* CMD推崇依赖就近，可以把依赖写进你的代码中的任意一行\n\n``` javascript\n// CMD\ndefine(function(require, exports, module) {\n  var a = require('./a');\n  a.doSomething()\n  // ...\n  var b = require('./b');  // 依赖可以就近书写\n  b.doSomething()\n  // ...\n});\n```\n\n代码在运行时，首先是不知道依赖的，需要遍历所有的 require 关键字，找出后面的依赖。具体做法是将 function toString 后，用正则匹配出 require 关键字后面的依赖。显然，这是一种牺牲性能来换取更多开发便利的方法。\n\n* AMD 推崇依赖前置，在解析和执行当前模块之前，模块作者必须指明当前模块所依赖的模块\n\n``` javascript\n// AMD\ndefine(['./a', './b'], function(a, b) { // 依赖必须一开始就写好\n  a.doSomething()\n  // ...\n  b.doSomething()\n  // ...\n});\n```\n\n代码在一旦运行到此处，能立即知晓依赖。而无需遍历整个函数体找到它的依赖，因此性能有所提升，缺点就是开发者必须显式得指明依赖——这会使得开发工作量变大，比如：当你写到函数体内部几百上千行的时候，忽然发现需要增加一个依赖，你不得不回到函数顶端来将这个依赖添加进数组。\n\n对比\n\n| 方案 | 优势 | 劣势 | 特点  |\n|----|:----:|:----:|----:|\n| AMD | 速度快 | 会浪费资源 | 预先加载所有的依赖，直到使用的时候才执行 |\n| CMD | 只有真正需要才加载依赖 | 性能较差 | 直到使用的时候才定义依赖 |",
  "bodyHtml": "<p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。</p>\n<p>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。</p>\n<p>--玉伯</p>\n<p>第一次听说 SeaJS，已经是两年前的事了，但一直没有机会让我意识到模块化对于前端开发的好处，所以也没有深入去了解使用 SeaJS 或者 RequireJS 这类的模块加载器进行模块化编程。</p>\n<p>随着公司项目越来越大，不管是代码维护还是新功能模块的添加，都越显困难与无力。模块化编程现在已经非常成熟，很多大的公司项目已经在使用，例如 QQ 空间、淘宝等。模块化编程在发展过程中，已经形成了多套规范以及基于不同规范的框架。本博文是我在探讨这些规范以及模块化框架过程中的一些总结与记录，已作分享以及备忘使用。</p>\n<h2>1. CommonJS规范</h2>\n<p>CommonJS 是服务器端模块化的规范，Node.js 就是基于 CommonJS Modules/1.0。</p>\n<p>根据 CommonJS 规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，在改模块内定义的变量无法被其他模块所读取，除非定义为global对象的属性。</p>\n<pre><code class=\"hljs\">// main.js\n\nglobal.name = 'Frend';</code></pre><p>以上定义的 name 变量可以被所有的模块所读取，但是并不推荐这种方式。输出模块的变量，最好的方式是使用 exports(module.exports) 对象。关于 <code>exports 与 module.exports的区别</code> 推荐看<a href=\"http://zihua.li/2012/03/use-module-exports-or-exports-in-node/\">一位全栈码农对 exports 与 module.exports 的分析</a>。如果这篇博文让你还是理解不了，那给出一个更加浅显的说明：exports 一般是一个对象，用于挂一堆的方法或者属性，例如一个 slider 滑动模块，有一堆的控制方法和属性，这种情况下就可以用 exports 来挂载，而另外一种情况，例如这个模块是叫 $G.dom.get，实现和 jQuery 的 $() 一样的功能，这时候不需要额外的一些乱七八糟的东西，只需要它是个方法，能直接调用，这时就可以使用 module.exports 了，调用的时候就可以直接通过 $get = require( './dom/get' ); $get 方法来使用了。</p>\n<pre><code class=\"hljs\">// module_a.js\n\nexports.name = 'Frend';\n\nexports.say = function() {\n  console.log(name);\n}</code></pre><p>使用 require 方法，加载 module_a.js</p>\n<pre><code class=\"hljs\">// main.js\n\nvar module_a = require('./module_a.js');    // 同步加载模块，加载完再执行后面的代码\n\nmodule_a.say(); // Frend</code></pre><h2>2. AMD规范</h2>\n<p>从 <a href=\"#commonjs\">#CommonJS 规范#</a>已经初步了解了 CommonJS，它加载模块时是同步的，也就是说，只有加载完成才会开始执行后面的操作。由于 Node.js 主要是用于服务器编程，模块文件一般是存放在服务器硬盘，所以加载会非常的快，不用考虑像浏览器请求脚本时造成阻塞等的情况，所以 CommonJS 规范比较适用。但是，如果是在浏览器，要从服务器加载模块，带宽是主要的瓶颈，所以 AMD 规范提倡的异步加载模块的方式比较适用。</p>\n<p>AMD（Asynchronous Module Definition）规范则是异步加载模块，即模块的加载不会影响后面语句的运行。所有依赖于某些模块的语句均放在回调函数中执行。\n<a href=\"https://github.com/amdjs/amdjs-api/wiki/AMD\">AMD规范</a></p>\n<h3>2.1 AMD 的全局变量 —— define 函数</h3>\n<h4>define(id?, dependencies?, factory)</h4>\n<p><code>id</code> 为可选参数，字符串类型，表示当前模块的标识。</p>\n<p><code>dependencies</code> 可选参数，当前模块所依赖并已经被定义的模块标志的数组字面量。</p>\n<p><code>factory</code> 一个模块需要执行一次的函数或者是分配了模块属性的的对象。</p>\n<ul>\n<li>创建模块标识为 alpha 的模块，依赖于 require，export，和标识为 beta 的模块</li>\n</ul>\n<pre><code class=\"hljs\">define('alpha', ['require', 'exports', 'beta'], function(require, exports, beta) {\n  export.verb = function() {\n    return beta.verb();\n  }\n});</code></pre><ul>\n<li>一个返回对象字面量的异步模块</li>\n</ul>\n<pre><code class=\"hljs\">define(['alpha'], function(alpha) {\n  return {\n    verb: function() {\n      return alpha.verb() + 1 ;\n    }\n  };\n});</code></pre><ul>\n<li>无依赖模块可以直接使用对象字面量来定义</li>\n</ul>\n<pre><code class=\"hljs\">define({\n  add: function(x, y) {\n    return x + y;\n  }\n});</code></pre><ul>\n<li>兼容 CommonJS 的写法</li>\n</ul>\n<pre><code class=\"hljs\">define(function(require, exports, module) {\n  var a = require('a'),\n      b = require('b');\n\n  exports.action = function(){};\n});</code></pre><h3>2.2 AMD 的 factory 中的 require 参数</h3>\n<ul>\n<li>require(String)</li>\n</ul>\n<pre><code class=\"hljs\">define(function(require) {\n  var a = require('a');   // 加载模块a\n});</code></pre><ul>\n<li>require(Array, Function)</li>\n</ul>\n<pre><code class=\"hljs\">define(function(require) {\n  require(['a', 'b'], function(a, b) {    // 加载模块a b 使用\n    // 依赖 a b 模块的运行代码\n  });\n});</code></pre><ul>\n<li>require.toUrl(Url)</li>\n</ul>\n<pre><code class=\"hljs\">define(function(require) {\n  var temp = require.toUrl('./temp/a.html');  // 加载页面\n});</code></pre><h2>3. CMD规范</h2>\n<p>CMD（Common Module Definition）规范是 SeaJS 遵循的规范，明确了模块的基本书写格式和基本交互规则。</p>\n<p>在该规范中，一个模块就是一个文件。</p>\n<p>###3.1 CMD 的全局变量 —— define 函数</p>\n<h4>define(id?, dependencies?, factory)</h4>\n<p><code>id</code> 为可选参数，字符串类型，表示当前模块的标识。</p>\n<p><code>dependencies</code> 为可选参数，数组类型，表示当前模块的依赖。</p>\n<p><code>factory</code> 可以是对象、字符串或者函数</p>\n<ul>\n<li>定义 JSON 数据模块</li>\n</ul>\n<pre><code class=\"hljs\">define({'foo': 'bar'});</code></pre><ul>\n<li>通过字符串定义模板模块</li>\n</ul>\n<pre><code class=\"hljs\">define('this is {{data}}.');</code></pre><ul>\n<li>factory 为函数的时候，表示模块的构造方法，执行构造方法便可以得到模块向外提供的接口</li>\n</ul>\n<pre><code class=\"hljs\">define(function(require, exports, module) {\n  // 模块代码\n});</code></pre><ul>\n<li>当拥有两个以上参数时</li>\n</ul>\n<pre><code class=\"hljs\">define('module', ['module1', 'module2'], function(require, exports, module) {\n  // 模块代码\n});</code></pre><p>从上面代码对比来看，CMD 与 AMD 规范在 define 函数上用法不相同。</p>\n<h3>3.2 CMD 的 factory 中的 require 参数</h3>\n<ul>\n<li><code>require(id);</code> 接受模块标识作为唯一的参数，用来获取其他模块提供的接口</li>\n</ul>\n<pre><code class=\"hljs\">define(function(require, exports) {\n  var a = require('./a');\n\n  a.doSomething();\n});</code></pre><ul>\n<li><code>require.async(id, callback?);</code> require 是同步往下执行的，需要的异步加载模块可以使用 require.async 来进行加载</li>\n</ul>\n<pre><code class=\"hljs\">define(function(require, exports, module) {\n  require.async('.a', function(a) {\n    a.doSomething();\n  });\n});</code></pre><h3>3.3 CMD 的 factory 中的 exports 参数</h3>\n<ul>\n<li>exports 用来向外提供模块接口</li>\n</ul>\n<pre><code class=\"hljs\">define(function(require, exports) {\n  exports.foo = 'bar';         // 向外提供的属性\n  exports.do = function() {};  // 向外提供的方法\n});</code></pre><ul>\n<li>使用 return 直接向外提供接口</li>\n</ul>\n<pre><code class=\"hljs\">define(function(require, exports) {\n  return {\n    foo: 'bar',         // 向外提供的属性\n    do: function() {}   // 向外提供的方法\n  }\n});</code></pre><ul>\n<li>简化为直接对象字面量的形式</li>\n</ul>\n<pre><code class=\"hljs\">define({\n  foo: 'bar',           // 向外提供的属性\n  do: function() {}     // 向外提供的方法\n});</code></pre><ul>\n<li>与 NodeJS 中一样需要注意的情况</li>\n</ul>\n<pre><code class=\"hljs\">// wrong\ndefine(function(require, exports) {\n  exports = {\n    foo: 'bar',           // 向外提供的属性\n    do: function() {}     // 向外提供的方法\n  }\n});\n\n// correct\ndefine(function(require, exports, module) {\n  module.exports = {\n    foo: 'bar',           // 向外提供的属性\n    do: function() {}     // 向外提供的方法\n  }\n});</code></pre><h3>3.4 CMD 的 factory 中的 module 参数</h3>\n<ul>\n<li>module 是 factory 的第三个参数，为一个对象，上面存储了一些与当前模块相关联的属性与方法</li>\n</ul>\n<pre><code class=\"hljs\">module.id           // 为模块的唯一标识。\nmodule.uri          // 根据模块系统的路径解析规则得到模块的绝对路径。\nmodule.dependencies // 表示模块的依赖。\nmodule.exports      // 当前模块对外提供的接口。</code></pre><h2>4. AMD 与 CMD 的区别</h2>\n<p>下面是玉伯对于 AMD 与 CMD 区别的解释：</p>\n<p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。</p>\n<p>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。</p>\n<p>AMD与CMD都是为了实现javascript的模块化开发，特别是在浏览器端。下面介绍两者的区别：</p>\n<ol>\n<li>\n<p>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</p>\n</li>\n<li>\n<p>CMD推崇依赖就近，AMD推崇依赖前置。</p>\n</li>\n</ol>\n<ul>\n<li>CMD推崇依赖就近，可以把依赖写进你的代码中的任意一行</li>\n</ul>\n<pre><code class=\"hljs\">// CMD\ndefine(function(require, exports, module) {\n  var a = require('./a');\n  a.doSomething()\n  // ...\n  var b = require('./b');  // 依赖可以就近书写\n  b.doSomething()\n  // ...\n});</code></pre><p>代码在运行时，首先是不知道依赖的，需要遍历所有的 require 关键字，找出后面的依赖。具体做法是将 function toString 后，用正则匹配出 require 关键字后面的依赖。显然，这是一种牺牲性能来换取更多开发便利的方法。</p>\n<ul>\n<li>AMD 推崇依赖前置，在解析和执行当前模块之前，模块作者必须指明当前模块所依赖的模块</li>\n</ul>\n<pre><code class=\"hljs\">// AMD\ndefine(['./a', './b'], function(a, b) { // 依赖必须一开始就写好\n  a.doSomething()\n  // ...\n  b.doSomething()\n  // ...\n});</code></pre><p>代码在一旦运行到此处，能立即知晓依赖。而无需遍历整个函数体找到它的依赖，因此性能有所提升，缺点就是开发者必须显式得指明依赖——这会使得开发工作量变大，比如：当你写到函数体内部几百上千行的时候，忽然发现需要增加一个依赖，你不得不回到函数顶端来将这个依赖添加进数组。</p>\n<p>对比</p>\n<table>\n<thead>\n<tr>\n<th>方案</th>\n<th style=\"text-align:center\">优势</th>\n<th style=\"text-align:center\">劣势</th>\n<th style=\"text-align:right\">特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>AMD</td>\n<td style=\"text-align:center\">速度快</td>\n<td style=\"text-align:center\">会浪费资源</td>\n<td style=\"text-align:right\">预先加载所有的依赖，直到使用的时候才执行</td>\n</tr>\n<tr>\n<td>CMD</td>\n<td style=\"text-align:center\">只有真正需要才加载依赖</td>\n<td style=\"text-align:center\">性能较差</td>\n<td style=\"text-align:right\">直到使用的时候才定义依赖</td>\n</tr>\n</tbody>\n</table>\n",
  "preview": "AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。\n\nCMD 是 SeaJS 在推广过程中对模块定义的规范化产出。\n\n--玉伯\n\n第一次听说",
  "dir": "content/posts/2015",
  "base": "02-01-fe-modules.json",
  "ext": ".json",
  "sourceBase": "02-01-fe-modules.md",
  "sourceExt": ".md"
}