{
  "layout": "post",
  "title": "跨域解决方案(基于nodejs)",
  "description": "跨域是web开发经常遇到的问题，也是前端开发需要具备的技能之一，目前主流处理跨域的方法有jsonp、cors、postMessage",
  "keywords": "跨域, jsonp, cors, postMessage",
  "date": "2015-07-02T01:20:00.000Z",
  "categories": "javascript",
  "bodyContent": "跨域是web开发过程中经常会遇见的一种问题，因为javascript的同源策略的限制，a.com域名下是无法操作b.com下的对象或者调用接口的。\n\n- 什么情况算跨域？\n\n|-----------------+------------+-----------------+----------------|\n| request url | response url | 说明 | 是否允许通讯 |\n|-----------------|:-----------|:---------------:|---------------:|\n| www.a.com/a.js | www.a.com/b.js | 同一域名 | 允许 |\n|-----------------+------------+-----------------+----------------|\n| www.a.com/a.js | www.a.com:8080/b.js | 同一域名，端口不同 | 不允许 |\n|-----------------+------------+-----------------+----------------|\n| http://www.a.com/a.js | https://www.a.com/b.js | 同一域名，协议不同 | 不允许 |\n|-----------------+------------+-----------------+----------------|\n| www.a.com/a.js | blog.a.com/b.js | 一级域名相同，二级域名不同 | 不允许 |\n|-----------------+------------+-----------------+----------------|\n| www.a.com/a.js | www.b.com/b.js | 不同域名 | 不允许 |\n|-----------------+------------+-----------------+----------------|\n\n<br/>\n\n目前解决跨域的方法比较多，通常有iframe、动态创建script、document.domain、flash、jsonp、cors、postMessage这几种。但本文只给出`jsonp`、`cors`与`postMessage`三种的测试例子。\n\n<br/>\n\n## 测试环境\n\n* node.js  ~0.12.0\n* express  ~4.12.1\n* jade     ~1.9.2\n\n<br/>\n\n## 1. JSONP\n\nJSONP跟JSON是什么关系？JSONP的实现原理是什么？我就不造轮子了，因为我也是看了别人的文章才理解的，直接推荐一篇[讲得很清晰的博文](http://kb.cnblogs.com/page/139725/)。了解后，就开始本地的代码测试吧。\n\n#### 本地模拟跨域\n\n本地要模拟跨域，一开始我是通过使用node启动一个地址为127.0.0.1:3000的server，然后本地在配一个frend.com（这个是nginx启动的一个静态资源server，端口是80，host配置中指向127.0.0.1）。然而这个在调试的过程中居然不跨域，普通的ajax请求居然通过了，这个我也不太理解。\n<br/>\n\n既然上面的情况不算跨域，那我只能起两个不同端口的server了。所以我在本地起了两个基于node的server，但端口分别为3000和3001，来实现跨域。以下就是通过两个端口不一样的服务来测试jsonp解决跨域的方案：\n\n- server1: localhost:3001，作为响应端\n\n响应端代码：\n\n![image](https://frender.github.io/blog/images/post/cross-origin/jsonp/res-code.png)\n\n响应端启动log：\n\n![image](https://frender.github.io/blog/images/post/cross-origin/jsonp/res-log.png)\n\n- server2: localhost:3000，作为请求端\n\n请求端代码：\n\n![image](https://frender.github.io/blog/images/post/cross-origin/jsonp/req-code.png)\n\n请求端启动log：\n\n![image](https://frender.github.io/blog/images/post/cross-origin/jsonp/req-log.png)\n\n- 浏览器访问localhost:3000，响应如下：\n\n![image](https://frender.github.io/blog/images/post/cross-origin/jsonp/req-browser.png)\n\n<br/>\n\n[☞下载JSONP例子源码☜](https://github.com/FrendEr/Cross-Origin)\n\n#### JSONP总结\n\nJSONP实现的原理很简单而且使用jquery的api会非常的方便，只需要配合后台定义好的接口。但是也有缺点，就是只支持GET的请求方式，如果需要使用POST或者传输大量的数据的时候，那我们就只能选择其他方式了，例如下面介绍的[CORS](#CORS)。\n\n<br/>\n\n## 2. CORS\n\nCORS(Cross-Origin Resource Sharing)即跨域资源共享，也是一种实现跨域访问的方法。\n\nCORS的实现原理很简单，只需要在响应端的头信息配置一个`Access-Control-Allow-Origin`的响应信息即可。\n\n- a) 没有配置`Access-Control-Allow-Origin`时，http://localhost:3000向http://localhost:3001发起ajax请求，跨域请求失败。\n\n- b) 设置`Access-Control-Allow-Origin: http://localhost:3000`：\n\n响应代码：\n\n![image](https://frender.github.io/blog/images/post/cross-origin/cors/res-code.png)\n\n请求代码：\n\n![image](https://frender.github.io/blog/images/post/cross-origin/cors/req-code.png)\n\n浏览器访问http://localhost:3000，响应如下：\n\n![image](https://frender.github.io/blog/images/post/cross-origin/cors/res-browser.png)\n\n- c) 设置`Access-Control-Allow-Origin: *`，注意这里的`*`是指所有来源都可以调用该接口：\n\n![image](https://frender.github.io/blog/images/post/cross-origin/cors/res-code2.png)\n\n请求代码：\n\n![image](https://frender.github.io/blog/images/post/cross-origin/cors/req-code.png)\n\n浏览器访问http://localhost:3000，响应如下：\n\n![image](https://frender.github.io/blog/images/post/cross-origin/cors/res-browser.png)\n\n[☞下载CORS例子源码☜](https://github.com/FrendEr/Cross-Origin)\n\n<br/>\n\n#### CORS总结\n\nCORS在使用起来非常方便，但也有缺点。\n\n- ① 兼容性，下图可见，对于需要兼容IE6-7的网站来说，这种方案还是存在着不满足需求的情况。但是对于现代浏览器，特别是在移动端可以放心使用。\n\n![image](https://frender.github.io/blog/images/post/cross-origin/cors/support.png)\n\n- ② 安全性\n\nCORS提供了一种简易的跨域请求方案，但是并没有为安全访问提供足够的保障机制，例如上面`Access-Control-Allow-Origin: *`的情况，所有使用者都可以请求改接口，这给服务端带来了巨大的安全隐患。如果需要保障安全，请参考[OAuth2](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)。\n\n<br/>\n\n## 3. postMessage\n\npostMessage是html5引入的message的API，可以更加方便、有效、安全的解决iframe嵌套跨域问题。详情见[postMessage使用文档 - MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage)。\n\n- 主页面\n\n![image](https://frender.github.io/blog/images/post/cross-origin/postMessage/parent-code.png)\n\n- iframe页面\n\n![image](https://frender.github.io/blog/images/post/cross-origin/postMessage/iframe-code.png)\n\n- 浏览器访问http://localhost:3000，响应如下：\n\n![image](https://frender.github.io/blog/images/post/cross-origin/postMessage/browser.png)\n\n[☞下载postMessage例子源码☜](https://github.com/FrendEr/Cross-Origin)\n\n<br/>\n\n## postMessage总结\n\npostMessage使用非常简单，但是在浏览器支持上对于IE6-7存在不足，如下图：\n\n![image](https://frender.github.io/blog/images/post/cross-origin/postMessage/support.png)\n\n但是现代浏览器对于使用postMessage还是非常有效的，特别是在移动端。",
  "bodyHtml": "<p>跨域是web开发过程中经常会遇见的一种问题，因为javascript的同源策略的限制，a.com域名下是无法操作b.com下的对象或者调用接口的。</p>\n<ul>\n<li>什么情况算跨域？</li>\n</ul>\n<p>|-----------------+------------+-----------------+----------------|</p>\n<table>\n<thead>\n<tr>\n<th>request url</th>\n<th style=\"text-align:left\">response url</th>\n<th style=\"text-align:center\">说明</th>\n<th style=\"text-align:right\">是否允许通讯</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>www.a.com/a.js</td>\n<td style=\"text-align:left\">www.a.com/b.js</td>\n<td style=\"text-align:center\">同一域名</td>\n<td style=\"text-align:right\">允许</td>\n</tr>\n<tr>\n<td>-----------------+------------+-----------------+----------------</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\"></td>\n</tr>\n<tr>\n<td>www.a.com/a.js</td>\n<td style=\"text-align:left\">www.a.com:8080/b.js</td>\n<td style=\"text-align:center\">同一域名，端口不同</td>\n<td style=\"text-align:right\">不允许</td>\n</tr>\n<tr>\n<td>-----------------+------------+-----------------+----------------</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\"></td>\n</tr>\n<tr>\n<td>http://www.a.com/a.js</td>\n<td style=\"text-align:left\">https://www.a.com/b.js</td>\n<td style=\"text-align:center\">同一域名，协议不同</td>\n<td style=\"text-align:right\">不允许</td>\n</tr>\n<tr>\n<td>-----------------+------------+-----------------+----------------</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\"></td>\n</tr>\n<tr>\n<td>www.a.com/a.js</td>\n<td style=\"text-align:left\">blog.a.com/b.js</td>\n<td style=\"text-align:center\">一级域名相同，二级域名不同</td>\n<td style=\"text-align:right\">不允许</td>\n</tr>\n<tr>\n<td>-----------------+------------+-----------------+----------------</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\"></td>\n</tr>\n<tr>\n<td>www.a.com/a.js</td>\n<td style=\"text-align:left\">www.b.com/b.js</td>\n<td style=\"text-align:center\">不同域名</td>\n<td style=\"text-align:right\">不允许</td>\n</tr>\n<tr>\n<td>-----------------+------------+-----------------+----------------</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\"></td>\n</tr>\n</tbody>\n</table>\n<p>&lt;br/&gt;</p>\n<p>目前解决跨域的方法比较多，通常有iframe、动态创建script、document.domain、flash、jsonp、cors、postMessage这几种。但本文只给出<code>jsonp</code>、<code>cors</code>与<code>postMessage</code>三种的测试例子。</p>\n<p>&lt;br/&gt;</p>\n<h2>测试环境</h2>\n<ul>\n<li>node.js  ~0.12.0</li>\n<li>express  ~4.12.1</li>\n<li>jade     ~1.9.2</li>\n</ul>\n<p>&lt;br/&gt;</p>\n<h2>1. JSONP</h2>\n<p>JSONP跟JSON是什么关系？JSONP的实现原理是什么？我就不造轮子了，因为我也是看了别人的文章才理解的，直接推荐一篇<a href=\"http://kb.cnblogs.com/page/139725/\">讲得很清晰的博文</a>。了解后，就开始本地的代码测试吧。</p>\n<h4>本地模拟跨域</h4>\n<p>本地要模拟跨域，一开始我是通过使用node启动一个地址为127.0.0.1:3000的server，然后本地在配一个frend.com（这个是nginx启动的一个静态资源server，端口是80，host配置中指向127.0.0.1）。然而这个在调试的过程中居然不跨域，普通的ajax请求居然通过了，这个我也不太理解。\n&lt;br/&gt;</p>\n<p>既然上面的情况不算跨域，那我只能起两个不同端口的server了。所以我在本地起了两个基于node的server，但端口分别为3000和3001，来实现跨域。以下就是通过两个端口不一样的服务来测试jsonp解决跨域的方案：</p>\n<ul>\n<li>server1: localhost:3001，作为响应端</li>\n</ul>\n<p>响应端代码：</p>\n<p><img src=\"https://frender.github.io/blog/images/post/cross-origin/jsonp/res-code.png\" alt=\"image\"></p>\n<p>响应端启动log：</p>\n<p><img src=\"https://frender.github.io/blog/images/post/cross-origin/jsonp/res-log.png\" alt=\"image\"></p>\n<ul>\n<li>server2: localhost:3000，作为请求端</li>\n</ul>\n<p>请求端代码：</p>\n<p><img src=\"https://frender.github.io/blog/images/post/cross-origin/jsonp/req-code.png\" alt=\"image\"></p>\n<p>请求端启动log：</p>\n<p><img src=\"https://frender.github.io/blog/images/post/cross-origin/jsonp/req-log.png\" alt=\"image\"></p>\n<ul>\n<li>浏览器访问localhost:3000，响应如下：</li>\n</ul>\n<p><img src=\"https://frender.github.io/blog/images/post/cross-origin/jsonp/req-browser.png\" alt=\"image\"></p>\n<p>&lt;br/&gt;</p>\n<p><a href=\"https://github.com/FrendEr/Cross-Origin\">☞下载JSONP例子源码☜</a></p>\n<h4>JSONP总结</h4>\n<p>JSONP实现的原理很简单而且使用jquery的api会非常的方便，只需要配合后台定义好的接口。但是也有缺点，就是只支持GET的请求方式，如果需要使用POST或者传输大量的数据的时候，那我们就只能选择其他方式了，例如下面介绍的<a href=\"#CORS\">CORS</a>。</p>\n<p>&lt;br/&gt;</p>\n<h2>2. CORS</h2>\n<p>CORS(Cross-Origin Resource Sharing)即跨域资源共享，也是一种实现跨域访问的方法。</p>\n<p>CORS的实现原理很简单，只需要在响应端的头信息配置一个<code>Access-Control-Allow-Origin</code>的响应信息即可。</p>\n<ul>\n<li>\n<p>a) 没有配置<code>Access-Control-Allow-Origin</code>时，http://localhost:3000向http://localhost:3001发起ajax请求，跨域请求失败。</p>\n</li>\n<li>\n<p>b) 设置<code>Access-Control-Allow-Origin: http://localhost:3000</code>：</p>\n</li>\n</ul>\n<p>响应代码：</p>\n<p><img src=\"https://frender.github.io/blog/images/post/cross-origin/cors/res-code.png\" alt=\"image\"></p>\n<p>请求代码：</p>\n<p><img src=\"https://frender.github.io/blog/images/post/cross-origin/cors/req-code.png\" alt=\"image\"></p>\n<p>浏览器访问http://localhost:3000，响应如下：</p>\n<p><img src=\"https://frender.github.io/blog/images/post/cross-origin/cors/res-browser.png\" alt=\"image\"></p>\n<ul>\n<li>c) 设置<code>Access-Control-Allow-Origin: *</code>，注意这里的<code>*</code>是指所有来源都可以调用该接口：</li>\n</ul>\n<p><img src=\"https://frender.github.io/blog/images/post/cross-origin/cors/res-code2.png\" alt=\"image\"></p>\n<p>请求代码：</p>\n<p><img src=\"https://frender.github.io/blog/images/post/cross-origin/cors/req-code.png\" alt=\"image\"></p>\n<p>浏览器访问http://localhost:3000，响应如下：</p>\n<p><img src=\"https://frender.github.io/blog/images/post/cross-origin/cors/res-browser.png\" alt=\"image\"></p>\n<p><a href=\"https://github.com/FrendEr/Cross-Origin\">☞下载CORS例子源码☜</a></p>\n<p>&lt;br/&gt;</p>\n<h4>CORS总结</h4>\n<p>CORS在使用起来非常方便，但也有缺点。</p>\n<ul>\n<li>① 兼容性，下图可见，对于需要兼容IE6-7的网站来说，这种方案还是存在着不满足需求的情况。但是对于现代浏览器，特别是在移动端可以放心使用。</li>\n</ul>\n<p><img src=\"https://frender.github.io/blog/images/post/cross-origin/cors/support.png\" alt=\"image\"></p>\n<ul>\n<li>② 安全性</li>\n</ul>\n<p>CORS提供了一种简易的跨域请求方案，但是并没有为安全访问提供足够的保障机制，例如上面<code>Access-Control-Allow-Origin: *</code>的情况，所有使用者都可以请求改接口，这给服务端带来了巨大的安全隐患。如果需要保障安全，请参考<a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\">OAuth2</a>。</p>\n<p>&lt;br/&gt;</p>\n<h2>3. postMessage</h2>\n<p>postMessage是html5引入的message的API，可以更加方便、有效、安全的解决iframe嵌套跨域问题。详情见<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage\">postMessage使用文档 - MDN</a>。</p>\n<ul>\n<li>主页面</li>\n</ul>\n<p><img src=\"https://frender.github.io/blog/images/post/cross-origin/postMessage/parent-code.png\" alt=\"image\"></p>\n<ul>\n<li>iframe页面</li>\n</ul>\n<p><img src=\"https://frender.github.io/blog/images/post/cross-origin/postMessage/iframe-code.png\" alt=\"image\"></p>\n<ul>\n<li>浏览器访问http://localhost:3000，响应如下：</li>\n</ul>\n<p><img src=\"https://frender.github.io/blog/images/post/cross-origin/postMessage/browser.png\" alt=\"image\"></p>\n<p><a href=\"https://github.com/FrendEr/Cross-Origin\">☞下载postMessage例子源码☜</a></p>\n<p>&lt;br/&gt;</p>\n<h2>postMessage总结</h2>\n<p>postMessage使用非常简单，但是在浏览器支持上对于IE6-7存在不足，如下图：</p>\n<p><img src=\"https://frender.github.io/blog/images/post/cross-origin/postMessage/support.png\" alt=\"image\"></p>\n<p>但是现代浏览器对于使用postMessage还是非常有效的，特别是在移动端。</p>\n",
  "preview": "",
  "dir": "content/posts/2015",
  "base": "07-02-cross-origin.json",
  "ext": ".json",
  "sourceBase": "07-02-cross-origin.md",
  "sourceExt": ".md"
}